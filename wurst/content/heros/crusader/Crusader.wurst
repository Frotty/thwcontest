package Crusader
import MapStuff
import Fx
import Creep
import Hero
import DummyCaster
import ChannelAbilityPreset
import AbilityObjEditing
import TempGroups
import TimerUtils
import ClosureEvents
import StunHandler
import ClosureForGroups
import ClosureTimers
import Lightning

int CRUSADER_ID

int BACKOFF_SPELL_ID
int SAFEGUARD_SPELL_ID

int DUMBACKOFF_SPELL_ID

public class Crusader extends Hero
	timer sg_timer //sg stands for SafeGuard spell
	real sg_remaining // Counts back from 6 seconds
	real sg_damage // saves incoming damage for healback
	Hero sg_target
	real sg_damagewindow
	
	construct(vec3 pos, player owner )
		super(pos, owner, CRUSADER_ID)
		
	override function onCast(int spellId)
		print("Crusader - onCast function called")
		switch spellId
			case BACKOFF_SPELL_ID
				castBackOff() 
	
	override function onUnitCast(int spellId, unit target)
		print("Crusader - onUnitCast function called")
		switch spellId
			case SAFEGUARD_SPELL_ID
				castSafeGuard(target) 
		
	override function onPointCast(int spellId, vec2 target)
	
	function castBackOff() // Q ability of Crusader. Instant cast.
		//DummyCaster dc = new DummyCaster(DUMBACKOFF_SPELL_ID,"stomp",owner, false) //Create dummy for stun
		//dc.recycleDelay = .5
		//dc.castInPoint(pos.toVec2().polarOffset(actor.getFacingAngle(), 100))
		real abilityrange = 400 //could be dynamic later?
		// From ClosureForGroups
		// forUnitsInRange(pos.toVec2(), abilityrange, (unit u) -> begin
		//       ^										  ^			  ^
		//       |										  |			  |
		//   (Function from package)	(parameter of the lambda expr)(starts a block if the expressions is more than 1 line)
		// This is an anonymous function (as you might know it from c++)
		// In this case it creates a closure which means it can capture local variables by value
		// FOr example see safe Guard
		// For more information on the topic: https://peq.github.io/WurstScript/manual.html#lambda_expressions_and_closures
		let eff = AddSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl",actor,"chest")
		eff.destr()
		forUnitsInRange(pos.toVec2(), abilityrange, (unit u) -> begin
			print("loop")
			if u.getEntity() instanceof Creep
				print("is creep")
				let creep = u.getEntity() castTo Creep
				var angl = pos.angleTo2d(creep.pos)
				if angl.radians < 0
					angl = angle(PI2 + angl.radians)
				print("angl = " + angl.degrees().toString() + "°")
				print("actor = " + actor.getFacingAngle().degrees().toString() + "°")
				if (angl - actor.getFacingAngle()).degrees().abs() < 60
					print("is angle")
					creep.addVel(vec3(angl.cos() * 10, angl.sin() * 10, 10))
					creep.actor.applyStun(false, 2, creep.owner)
		end)

				//dc.castOnTarget(c.actor)
				//ENUM_GROUP.removeUnit(u) // Will this fuck the for cylce up?
		//dc.castOnGroup(ENUM_GROUP) //Using dummycaster's corresponding function.
		//destroy dc
		
	OnDamage onDamageClosure
		
	function castSafeGuard(unit target) // E ability of Crusader. Allied hero cast.
		// Should probably work on summouns (of there every happen any) too
		let targetEntity = target.getEntity()
		if target == actor //Different effect if casted on self.
			print("yuo cheating!")
		else
			print("created")
			// Create local vars to be captured by closure (ignore warning)
			let speed = 20.
			setTarget(targetEntity.pos.toVec2(),speed)
			var jump_duration = pos.distToVec2d(targetEntity.pos) / speed //Using the same formula as the setTarget() function here.
			if jump_duration < 1.
				jump_duration = 1./speed
			jump_duration *= ANIMATION_PERIOD
			doAfter(jump_duration, () -> begin //We only add the effects of the ability when the jump is done.
				let channel_duration = 5.
				let maxDistance = 500
				let lng = addLightning("LEAS", true, pos, targetEntity.pos)
				let eff = AddSpecialEffectTarget("Abilities\\Spells\\Human\\ManaShield\\ManaShieldCaster.mdl",targetEntity.actor,"origin")
				doAfter((channel_duration-5.), ()-> eff.destr())
				doPeriodicallyTimed(ANIMATION_PERIOD, channel_duration, (CallbackCounted cb) -> begin
					var col = lng.getColor()
					col.alpha = ((maxDistance - (pos.distToVec(targetEntity.pos) / maxDistance)) * 255).toInt()
					lng..move(true, pos, targetEntity.pos)
					..setColor(col)
					if cb.isLast()
						lng.destr()
				end)
			end)
	
		
	function safeGuard_onDamage()
		real damage = 10 //to be set normally
		sg_damage += damage
		sg_damagewindow += damage
		
public function init_Crusader(boolean compiletime)
	CRUSADER_ID = HERO_ID_GEN.next()
	// generate valid id
	BACKOFF_SPELL_ID = ABIL_ID_GEN.next()
	SAFEGUARD_SPELL_ID = ABIL_ID_GEN.next()
	DUMBACKOFF_SPELL_ID = ABIL_ID_GEN.next()
	
	if compiletime
		// Generate def if compieltime
		var spreset = new ChannelAbilityPreset(BACKOFF_SPELL_ID, 4)
		// Set Attributes
		spreset..removeChannelProperties(true)..setName("Back Off")..setButtonPositionNormalX(0)..setButtonPositionNormalY(2)
			..setIcon("BTNWarStomp")..setOption(Option.VISIBLE, true) //Or whatever...
		
		spreset = new ChannelAbilityPreset(SAFEGUARD_SPELL_ID, 4)
		// Set Attributes
		spreset..removeChannelProperties(true)..setName("Safeguard")..setButtonPositionNormalX(1)..setButtonPositionNormalY(2)
			..setIcon("BTNDefend")..setOption(Option.VISIBLE, true)
			..setCastRange(1,400)..setTargetType(Targettype.UTARGET)
			..setTargetsAllowed(1,"allied")
		
		/*let adef = new AbilityDefinitionWarStompcreep(DUMBACKOFF_SPELL_ID)
		adef..setCooldown(1, 0)..setManaCost(1, 0) //Missing presets ehre 
		..setLevels(1)..setAreaofEffect(1, 300) // Done
		*/
		let preset = new HeroPreset(CRUSADER_ID, 'Hlgr', "Crusader")
		preset..addProperName("Matija")
			..setModelFile("units\\human\\TheCaptain\\TheCaptain.mdl")
			..addHeroAbility(idInteger2IdString(BACKOFF_SPELL_ID))
			..addHeroAbility(idInteger2IdString(SAFEGUARD_SPELL_ID))
		// Build at the end
			..buildHero()
		
		
