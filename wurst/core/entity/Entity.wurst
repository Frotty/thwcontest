package Entity
import LinkedListModule
import Terrain
import public Fx
import Angle
import GameConstants
import GameTimer
import public LinkedList

public function item.getEntity() returns Entity
	return this.getUserData() castTo Entity
	
public function item.setEntity(Entity e)
	this.setUserData(e castTo int)

public function unit.getEntity() returns UnitEntity
	return this.getUserData() castTo UnitEntity
	
public function unit.setEntity(UnitEntity e)
	this.setUserData(e castTo int)

/** Base Entity Class  */
public abstract class Entity
	use LinkedListModule
	
	/** 3d vector position */
	protected vec3 pos
	/** 3d vector velocity */
	protected vec3 vel
	
	real lastPosChange = 0.
	
	/** radius */
	real radius = 0.
	/** speed factor (multiplies to added velocity) */
	real speedFactor = 1.
	
	/** owning player */
	player owner
	
	/** flag for being static */
	boolean isStatic 	= false
	/** sleeping or active? */
	boolean active 		= true
	boolean needPhysicsUpdate = false


	construct( vec3 pos, player owner )
		this.pos = pos
		this.vel = vec3(0,0,0)
		this.owner = owner		

	construct( vec3 pos, real radius, player owner )
		this.pos = pos
		this.vel = vec3(0,0,0)
		this.owner = owner
		this.radius = radius
		
	construct( vec3 pos, vec3 vel, player owner )
		this.pos = pos
		this.vel = vel
		this.owner = owner
		
	construct( vec3 pos, vec3 vel, real radius, player owner )
		this.pos = pos
		this.vel = vel
		this.owner = owner
		this.radius = radius
		
	function getPos() returns vec3
		return pos
		
	function getVel() returns vec3
		return vel
		
	function scaleVel(real factor)
		vel *= factor
		
	function getPos2d() returns vec2
		return vec2(pos.x, pos.y)
		
	function setPos( vec3 pos, boolean wakeUp )
		this.pos = pos
		lastPosChange = currentTime
		if wakeUp
			active = true
		
	function addPos( vec3 pos, boolean wakeUp )
		this.pos += pos
		lastPosChange = currentTime
		if wakeUp
			needPhysicsUpdate = true
		
	function setVel( vec3 vel )
		this.vel = vel
		needPhysicsUpdate = true
		
	function setZ( real z )
		this.pos.z = z
		needPhysicsUpdate = true
	
	function addVel( vec3 vel )
		this.vel += vel
		needPhysicsUpdate = true
		
	function setTarget( vec2 tpos, real speed )
		active = true
		let spd = (speed * ANIMATION_PERIOD)
		var t = pos.distToVec2d(tpos) / spd
		let tangle = pos.angleTo2d(tpos)
		let e = getTerrainZ(tpos)
		if t < 1.
			t = 1. / spd
		
		let startZVelocity = ((-gravity.z * t) / 2 - pos.z/t + e/t)
		this.setVel( vec3( tangle.radians().cos() * spd, tangle.radians().sin() * spd, startZVelocity) )
				
	/** This function is called every ANIMATION_PERIOD tick if the Entity is active */
	abstract function update()
	
	ondestroy
		print("ondestroy Entity")
	
abstract public class UnitEntity extends Entity
	unit actor
	
	construct( vec3 pos, unit actor )
		super(pos, actor.getOwner())
		this.actor = actor
		actor
			..setUserData(this castTo int)
			..addAbility(HEIGHT_ENABLER)
			..removeAbility(HEIGHT_ENABLER)
		
	construct( vec3 pos, real radius, unit actor )
		super(pos, radius, actor.getOwner())
		this.actor = actor
		actor
			..setUserData(this castTo int)
			..addAbility(HEIGHT_ENABLER)
			..removeAbility(HEIGHT_ENABLER)
	
	static function getForUnit(unit u) returns UnitEntity
		return u.getUserData() castTo UnitEntity
		
	function setNewActor(unit u)
		actor.remove()
		actor = u
		actor.setUserData(this castTo int)
		
	override function addPos( vec3 pos, boolean wakeUp )
		this.pos = getPosZ()
		this.pos += pos
		lastPosChange = currentTime
		if wakeUp
			needPhysicsUpdate = true
		
	override function getPos() returns vec3
		if lastPosChange < currentTime
			lastPosChange = currentTime
			pos = vec3(actor.getX(), actor.getY(), pos.z)
		return pos
		
	override function getPos2d() returns vec2
		if lastPosChange < currentTime
			lastPosChange = currentTime
			pos = vec3(actor.getX(), actor.getY(), pos.z)
		return vec2(pos.x, pos.y)
			
	function getPosZ() returns vec3
		if lastPosChange < currentTime
			lastPosChange = currentTime
			pos = vec3(actor.getX(), actor.getY(), 0)
			pos.z = getTerrainZ(pos.x, pos.y) + actor.getFlyHeight()
		return pos
		
	function setPos(vec3 tpos, real tZ)
		needPhysicsUpdate = true
		pos = tpos
		actor.setPos(tpos.x,tpos.y)
		actor.setFlyHeight(tpos.z - tZ, 0)
		
	function setXYZ(vec3 tpos, real tZ)
		needPhysicsUpdate = true
		pos = tpos
		actor.setXY(tpos.x,tpos.y)
		actor.setFlyHeight(tpos.z - tZ, 0)
		
	override function setVel( vec3 vel )
		if lastPosChange < currentTime
			lastPosChange = currentTime
			pos = vec3(actor.getX(), actor.getY(), 0)
			pos.z = getTerrainZ(pos.x, pos.y) + actor.getFlyHeight()
		this.vel = vel
		needPhysicsUpdate = true
	
	override function addVel( vec3 vel )
		if lastPosChange < currentTime
			lastPosChange = currentTime
			pos = vec3(actor.getX(), actor.getY(), 0)
			pos.z = getTerrainZ(pos.x, pos.y) + actor.getFlyHeight()
		this.vel += vel
		needPhysicsUpdate = true
		

abstract public class FxEntity extends Entity
	Fx fx
	
	construct( vec3 pos, real radius, player owner, angle xyAngle, string sfxpath )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle, sfxpath)
		fx.setOwner(owner, true)
		
	construct( vec3 pos, real radius, player owner, angle xyAngle )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
	
	construct( vec3 pos, player owner, angle xyAngle )
		super(pos, 0., owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
		
	override function update()
		pos += (vel*speedFactor)
		fx.setPos(pos)
		
	function setFx(string sfxpath)
		fx.setFx(sfxpath)
		
	function getDummy() returns unit
		return fx.getDummy()
		
	override function setPos(vec3 tpos, boolean wakeUp)
		super.setPos(tpos, wakeUp)
		fx.setPos(tpos.x,tpos.y)
		
	ondestroy
		print("ondestroy FxEntity1")
		destroy fx
		print("ondestroy FxEntity2")

function updateEntities()
	Entity e = Entity.first
	while e != null
		if e.active
			e.update()
		e = e.next

public function startEntityLoop()
	CreateTimer().startPeriodic(ANIMATION_PERIOD, function updateEntities)


	