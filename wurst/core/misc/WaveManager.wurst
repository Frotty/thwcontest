package WaveManager
import WavePool
import Spawner
import ClosureTimers
import GameTimer
import Intermission
import GameConstants

constant INTERMISSION_DURATION = 30.

public class WaveManager
	static Queue<WavePool> waves
	static WavePool currentWave = null
	static timer waveTimer = CreateTimer()
	static real waveStartTime
	static boolean finished = false
	
	static function addAllWaves(Queue<WavePool> waves)
		WaveManager.waves = waves
		
	static function startNextWave()
		if currentWave != null
			destroy currentWave
		currentWave = waves.dequeue()
		waveStartTime = getElapsedGameTime()
		let wave_duration = currentWave.getDuration()
		finished = false
		doPeriodicallyTimed(0.25, wave_duration, (CallbackCounted cb) -> begin
			let gameTime = getElapsedGameTime()
			for sp in currentWave.spawns
				if waveStartTime + sp.time < gameTime and sp.amount > 0
					spawn(sp)
			if cb.isLast()
				WaveManager.onPropertyTrig.enable()
				doAfter(30, () -> begin
					if not finished
						finished = true
						WaveManager.onPropertyTrig.disable()
				end)
		end)
		
	static trigger onPropertyTrig = CreateTrigger()
	
		
	static function spawn(SpawnContainer sc)
		switch sc.where
			case SpawnerGroup.ALL
				for s in spawners
					s.spawnCreep(sc.creepDef)
			case SpawnerGroup.NORTH
				NORTH.spawnCreep(sc.creepDef)
			case SpawnerGroup.EAST
				EAST.spawnCreep(sc.creepDef)
			case SpawnerGroup.WEST
				WEST.spawnCreep(sc.creepDef)
		sc.amount--
					
init
	WaveManager.onPropertyTrig..registerPlayerStateEvent(CREEP_PLAYER, PLAYER_STATE_RESOURCE_FOOD_USED, LESS_THAN_OR_EQUAL, 0.00)
	..addAction(() -> begin
		WaveManager.finished = true
		startIntermission(INTERMISSION_DURATION)
		WaveManager.onPropertyTrig.disable()
		doAfter(INTERMISSION_DURATION, () -> WaveManager.startNextWave())
	end)
	WaveManager.onPropertyTrig.disable()
